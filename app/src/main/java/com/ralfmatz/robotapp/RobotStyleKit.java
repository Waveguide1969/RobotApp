package com.ralfmatz.robotapp;

import android.graphics.Paint;
import android.graphics.RectF;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Path;



/**
 * Created by Ralf Matz on 12.07.17.
 * Copyright Â© 2017 CompanyName. All rights reserved.
 *
 * Generated by PaintCode
 * http://www.paintcodeapp.com
 *
 * @author Ralf Matz
 */
public class RobotStyleKit {
    
    
    // Resizing Behavior
    public enum ResizingBehavior {
        AspectFit, //!< The content is proportionally resized to fit into the target rectangle.
        AspectFill, //!< The content is proportionally resized to completely fill the target rectangle.
        Stretch, //!< The content is stretched to match the entire target rectangle.
        Center, //!< The content is centered in the target rectangle, but it is NOT resized.
    }
    
    // Canvas Drawings
    // Tab
    
    private static class CacheForRobotHead {
        private static Paint paint = new Paint();
        private static RectF originalFrame = new RectF(0f, 0f, 240f, 120f);
        private static RectF resizedFrame = new RectF();
        private static RectF rectangleRect = new RectF();
        private static Path rectanglePath = new Path();
        private static RectF ovalRect = new RectF();
        private static Path ovalPath = new Path();
        private static RectF oval2Rect = new RectF();
        private static Path oval2Path = new Path();
        private static RectF oval3Rect = new RectF();
        private static Path oval3Path = new Path();
    }
    
    public static void drawRobotHead(Canvas canvas) {
        RobotStyleKit.drawRobotHead(canvas, new RectF(0f, 0f, 240f, 120f), ResizingBehavior.AspectFit);
    }
    
    public static void drawRobotHead(Canvas canvas, RectF targetFrame, ResizingBehavior resizing) {
        // General Declarations
        Paint paint = CacheForRobotHead.paint;
        
        // Local Colors
        int color2 = Color.argb(255, 215, 31, 31);
        int color = Color.argb(255, 89, 171, 165);
        
        // Resize to Target Frame
        canvas.save();
        RectF resizedFrame = CacheForRobotHead.resizedFrame;
        RobotStyleKit.resizingBehaviorApply(resizing, CacheForRobotHead.originalFrame, targetFrame, resizedFrame);
        canvas.translate(resizedFrame.left, resizedFrame.top);
        canvas.scale(resizedFrame.width() / 240f, resizedFrame.height() / 120f);
        
        // Rectangle
        RectF rectangleRect = CacheForRobotHead.rectangleRect;
        rectangleRect.set(38f, 21f, 139f, 74f);
        Path rectanglePath = CacheForRobotHead.rectanglePath;
        rectanglePath.reset();
        rectanglePath.addRoundRect(rectangleRect, 5f, 5f, Path.Direction.CW);
        
        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(Color.GRAY);
        canvas.drawPath(rectanglePath, paint);
        
        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setStrokeWidth(1f);
        paint.setStrokeMiter(10f);
        canvas.save();
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(Color.BLACK);
        canvas.drawPath(rectanglePath, paint);
        canvas.restore();
        
        // Oval
        RectF ovalRect = CacheForRobotHead.ovalRect;
        ovalRect.set(56f, 45f, 121f, 68f);
        Path ovalPath = CacheForRobotHead.ovalPath;
        ovalPath.reset();
        ovalPath.addOval(ovalRect, Path.Direction.CW);
        
        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(color);
        canvas.drawPath(ovalPath, paint);
        
        // Oval 2
        RectF oval2Rect = CacheForRobotHead.oval2Rect;
        oval2Rect.set(56.5f, 28.5f, 69.5f, 40.5f);
        Path oval2Path = CacheForRobotHead.oval2Path;
        oval2Path.reset();
        oval2Path.addOval(oval2Rect, Path.Direction.CW);
        
        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(color2);
        canvas.drawPath(oval2Path, paint);
        
        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setStrokeWidth(1f);
        paint.setStrokeMiter(10f);
        canvas.save();
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(Color.BLACK);
        canvas.drawPath(oval2Path, paint);
        canvas.restore();
        
        // Oval 3
        RectF oval3Rect = CacheForRobotHead.oval3Rect;
        oval3Rect.set(108.5f, 28.5f, 121.5f, 40.5f);
        Path oval3Path = CacheForRobotHead.oval3Path;
        oval3Path.reset();
        oval3Path.addOval(oval3Rect, Path.Direction.CW);
        
        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setStyle(Paint.Style.FILL);
        paint.setColor(color2);
        canvas.drawPath(oval3Path, paint);
        
        paint.reset();
        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
        paint.setStrokeWidth(1f);
        paint.setStrokeMiter(10f);
        canvas.save();
        paint.setStyle(Paint.Style.STROKE);
        paint.setColor(Color.BLACK);
        canvas.drawPath(oval3Path, paint);
        canvas.restore();
        
        canvas.restore();
    }
    
    
    // Resizing Behavior
    public static void resizingBehaviorApply(ResizingBehavior behavior, RectF rect, RectF target, RectF result) {
        if (rect.equals(target) || target == null) {
            result.set(rect);
            return;
        }
        
        if (behavior == ResizingBehavior.Stretch) {
            result.set(target);
            return;
        }
        
        float xRatio = Math.abs(target.width() / rect.width());
        float yRatio = Math.abs(target.height() / rect.height());
        float scale = 0f;
        
        switch (behavior) {
            case AspectFit: {
                scale = Math.min(xRatio, yRatio);
                break;
            }
            case AspectFill: {
                scale = Math.max(xRatio, yRatio);
                break;
            }
            case Center: {
                scale = 1f;
                break;
            }
        }
        
        float newWidth = Math.abs(rect.width() * scale);
        float newHeight = Math.abs(rect.height() * scale);
        result.set(target.centerX() - newWidth / 2,
            target.centerY() - newHeight / 2,
            target.centerX() + newWidth / 2,
            target.centerY() + newHeight / 2);
    }
    
    
}